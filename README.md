**Table Of Contents:**
1. About/Overview
2. How to Get Started
3. Documentation and Key Components
4. Code Base Organization

**About/Overview:**
**Sanguine** is a two-player game that is played on a board with cells and custom decks of cards inspired by _Queen's Blood_. Each player uses a deck of cards with influence patterns that affect the gameboard and allow a player to gain more territory and

Therefore, this codebase is a simple digital implementation of Sanguine with a model and textual view. It focuses on displaying the current game states, enforcing game rules, and running a game from start to finish. The textual view is human-readable, so any person should be able to play and understand the game format after reading the game rules.

Assumptions:
- The game is turn-based, and players must alternate decisions and actions
- Each player must come in with a valid deck of Sanguine cards, which may be auto-generated by the model if the deck is invalid or not provided
- Game objects include pawns, Sanguine cards, and a game board
- The game automatically keeps running until both players pass their turns
- The board size, player hand size, and deck size are all customizable
- This is a simple version of _Queen's Blood_ so only pawns are influenced by the cards, which may be different from more advanced game versions

We also envision that our codebase can be extended to create a GUI using Java Swing so that the view is upgraded from a textual view and is more pleasant.

**How to Get Started:**
To run the program, head over to the [Sanguine Main Method](src/main/java/sanguine/Sanguine.java) and press the run button.
Alternatively, you can run these commands in the terminal:
javac -d out src/main/java/sanguine/Sanguine.java
java -cp out sanguine.SanguineGame docs/deck.config

**Documentation and Key Components:**
**Key Components:**
- BasicSanguineModel (implements SanguineModel):
  This is the model that represents the game. It tracks the gameboard which contains pawns, cards, or nothing at any given moment. It also enforces turn order, moves, and the influence rules of the cards. Additionally, it deals with scoring and determining the winner. This class essentially drives the control flow of the game objects.

- SanguinePlayer (implements Player):
  This is used as a representation of a player playing Sanguine. There are two main versions: a red and a blue player. They hold a deck and a hand.

- SanguineGameBoard (implements GameBoard):
  This is used as a representation of a game board in Sanguine. It is composed of a class called BasicSanguineBoardCell (implements SanguineBoardCell), which holds game objects like pawns and cards and tracks ownership. This game board is the backbone of a game of Sanguine and exists for there to be a place to put other game objects.

- BasicSanguineCard (implements Card and SanguineCard):
  This is used as a representation of cards in Sanguine. Cards are used as the driving force in a game for players. When players place cards, it influences the game board accordingly, so this is an essential component. Cards have a name, value, cost, and influence grid. The model mentioned above deals with how cards change the state of the game. When toString() is used on this class, it prints the card in this format:
  [Name] [Cost] [Value]
  ROW_0
  ROW_1
  ROW_2
  ROW_3
  ROW_4
  (rows are influence grid)

- PlayerColor & CardColor (enum):
  Player colors define RED and BLUE and are used for board ownership and rendering. Card colors are used in the card class implementation; however, we do not use them within the model. We added this to our codebase because we might need it the future when creating a GUI and displaying card faces.

- TieException:
  This is used in the model whenever a tie between players is detected when scoring the game or finding the winner.

- DeckReader:
  This is used to read and validate deck config files. It parses through card information, ensures that a card's value, cost, and influence grid are valid, and then converts it into a Card object.

- Textual View:
  This is used to render the board row by row. It uses the symbols:
  _: for an empty cell
  1, 2, 3: for pawn counts
  R: for a red player's card
  B: for a blue player's card

- Sanguine (Main Class):
  This allows us to run the program. It reads a deck path from args[0], initializes the model while creating decks for both players and prints the textual view after each move.

**Code Base Organization:**
Sanguine/
- docs/:
1. deck.config
2. example.deck
3. invalidDeckForTests.txt

- src/:
1. Sanguine Main Class

- src/main/java/sanguine/model/:
1. BasicSanguineBoardCell.java
2. BasicSanguineCard.java
3. BasicSanguineModel.java
4. BasicSanguinePawn.java
5. Card.java
6. CardColor.java
7. DeckParser.java
8. GameBoard.java
9. Pawn.java
10. Player.java
11. PlayerColor.java
12. SanguineBoardCell.java
13. SanguineCard.java
14. SanguineGameBoard.java
15. SanguineModel.java
16. SanguinePawn.java
17. SanguinePlayer.java
18. TieException.java

- src/main/java/sanguine/tests
1. CardTests.java
2. CellTests.java
3. DeckParserTest.java
4. GameBoardTests.java
5. PlayerTests.java
6. SanguineModelTests.java
7. TextualViewTests.java


**Changes for part2**
Added Missing Observations to the SanguineModel: 
- The ability to get the contents of a cell at a given coordinate.
    + Solution: new method getCellAt(int row, int col) in the model.
    + This was added because we will need to get the contents of a specific cell for our       GUI when creating cell Panels.
- The ability to get the contents of player's hand.
    + Solution: new method getPlayerHand(PlayerColor color) in the model.
    + This was added so that we can get a specific player's hand for the GUI when              displaying their hand at the bottom of the screen.
- The ability to see which player owns the card or pawns in the cell at a given            coordinate. 
    + Solution: new method getOwnershipOfCell(int row, int col) in the model.
    + This was added so that we can understand which player color to put in the GUI for        a pawn or card.
- Whether it is legal for the current player to play a given card. 
    + Solution: new method placeCardLegal(int row, int col, SanguineCard card,                 SanguinePlayer player) in the model.
    + This was added so that we can know whether a player can place a card in that given       spot for the stub controller. 
 - The ability to get a player's row-score in the game given a row index. 
    + Solution: new method getRowScore(PlayerColor color, int row) in the model.
    + This was added so that we can get the player row scores for the GUI panels that          display the player row scores on the left and right side
- The ability to get a current player's score in the game. 
    + Solution: new method getPlayerHand(PlayerColor color) in the model.
    + This was added so that we can get a specific player's hand for the GUI when              displaying their hand at the bottom of the screen.

**New Classes Created Explanation:**
- We created a SanguineViewFrame, which displays all of our panels that we created which include:
    + CardHandPanel which organizes a collection of CardPanels from both player's when         it is their turn. It formats them in a gridLayout() with unspecified rows and            columns, making it a row of cards. CardPanels display the cards name, value, cost,       and influence grid using Graphics2D. Then CardHandPanel has two helper methods           that display red cards or blue cards. These create a new CardPanel each time             CardHandPanel is refreshed.
    + GameBoardPanel which organizes a collection of CellPanels that either display            pawns, or a card. It formats them in a gridLayout() with specified rows and              columns taken from the model. CellPanels use Graphics2D to draw the pawns or the         card value number. Then GameBoardPanel simply initilizes these cells in the              constructor and it updates accordingly.
- We created a StubController interface and an implementation called SanguineStubController. The controller plays the game and decides what to do when certain events are fired. 
- We created a Listener interface that the Stub Controller implements so that it can decide what to do when certain panels on the screen are clicked or keys are pressed. 

**User Keyboard Input for Move and Pass**
When a player wants to **pass** their turn, they can press 'p' on their keyboard. 
When a player wants to make a **move** for their turn, they can press 'm' on their keyboard. 

**Model Interface Seperation**
- The view takes in a read only (non modifiable model), so we made an interfae for that called ModelReadOnlyInterface.
  - This is isGameOver, getBoard (returning a deep copy), getScore, getWinner, getTurn, getCellAt, getPlayerHand,
  - getOwnerShipOfCell, getRowScore, placeCardLegal
- The controller needs to run methods it, so we created SanguineModifyModel.
    - this is: startGame, createDeck, passTurn, playTurn
- The BasicSanguineModel implements them both. We can make sure that the view can only call view methods to the model,
avoiding the risk of it accidentally changing the model. The controller can access the methods PlayTurn, pass turn, 
createDeck, and startgame. the rest of the methods are private.
- The only changes we had to make was splitting the previous interface that BasicSanguineModel implemented into two,
based off the methods. we then made BasicSanguineModel implement both of those new interfaces. this 

**Extra credit**
- we implemented the MaxOwnership and Minimax strategies in the strategies package. their tests are in the tests package.

*Changes made in part 3*
**Changes to view:**
First we added a new method called showError(String). This creates a pop-up on the view for a specific player when they break a rule of the game. The player can then click off of the message after they realize what they did wrong.
Then we added a new method called changeInteraction(boolean). We decided that we will disable the ability to click on the other player’s view when it is not their turn. For example, if it is the Red player’s turn, we will disable interaction on the Blue player’s view so that the Red player can not click on the blue player’s view. This makes it so that we do not have to produce an error message pop-up and eventually the player should figure out they are clicking on the wrong view if necessary.
At first when we designed the view, we assumed we would have one frame that when refreshed automatically switches components to the other player’s turn. However, with this assignment, we were told that we needed two views, one for each player. So we made the constructor take in a player color. That way each view is dedicated to a specific player. Then we had to edit the card hand panel so that it is shown for only either a red or blue player.
Also added method removeHighlight() which will essentially reset the highlighted cards and panels on the GUI. This was helpful because when a player finishes their turn, we don’t want the cards and cells to still be highlighted.

**Changes to Model:**
Made the model a publisher and the controllers subscribe to it. The model implements ModelControllerPublisher. Interface is described in a later section. Model alerts every subscriber (two controllers) with the color of the current player. This method is called in changeturn().

**Controller:**

**SanguinePlayerController**
Implements the ModelListener class. Implementation of the turnChanged() method calls the notifyTurn on the player in the controller.
Implements Listener and for each method, communicates between the model and view to play the game.
Implements PlayerControllerInterface which only holds one method to set the view. This is because there is a loop for instantiation with MVC so we took setting the view out of the constructor and put it in a seperate method.

**PlayerControllerInterface:**


**UserPlayer:**
This interface is a representation of an actual player in a game of Sanguine. It is not the version the model uses, but a version the controller uses. The only methods in this are notifyTurn() and subscribe(). The lack of methods in this is intentional because an actual player in Sanguine can only see if it's their turn in order to make a move. And then we added subscribe because UserPlayer will always be a publisher for its own controller.

**AIPlayer:**
This is an implementation of UserPlayer for an AI or machine player. At its instantiation it sets a strategy, player color, and read only model. Additionally, the AiPlayer has a list of listeners. The listener we anticipate is just the controller. We decided to set a strategy at instantiation that can not change because we do not want an AI player’s strategy to change during a game. This is because we envision having different difficulties that an AI player can be set to when a human wants to play against AI. So we would consider the FirstSpot strategy to be easiest whereas the MiniMax strategy would be the most difficult because it considers all three strategies we created. So if a human wants to change the AI player they play against, they can start a new game and instantiate the AI player with a new strategy. Then for notifyTurn(), we have the AI player consider its strategy. If its strategy says to pass, the AI player calls pressP() on the controller. If the strategy says to play, the AI player calls pressM() and then calls clickCard(), clickCell() etc. to make sure the controller knows what the move is.

**HumanPlayer:**
This is an implementation of UserPlayer for a human player. At its instantiation it sets only a player color. This is because the human player can see the view so it does not need a read-only model. Additionally, the HumanPlayer has a list of listeners. The listener we anticipate is just the controller. Nothing needs to happen in notifyTurn() because the player will get a pop up saying it is their turn on the view. Additionally, subscribe() does not actually subscribe the controller to the view because the controller will be listening to the view for human player input.