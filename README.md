**Table Of Contents:**
1. About/Overview
2. How to Get Started
3. Documentation and Key Components
4. Code Base Organization

**About/Overview:**
**Sanguine** is a two-player game that is played on a board with cells and custom decks of cards inspired by _Queen's Blood_. Each player uses a deck of cards with influence patterns that affect the gameboard and allow a player to gain more territory and

Therefore, this codebase is a simple digital implementation of Sanguine with a model and textual view. It focuses on displaying the current game states, enforcing game rules, and running a game from start to finish. The textual view is human-readable, so any person should be able to play and understand the game format after reading the game rules.

Assumptions:
- The game is turn-based, and players must alternate decisions and actions
- Each player must come in with a valid deck of Sanguine cards, which may be auto-generated by the model if the deck is invalid or not provided
- Game objects include pawns, Sanguine cards, and a game board
- The game automatically keeps running until both players pass their turns
- The board size, player hand size, and deck size are all customizable
- This is a simple version of _Queen's Blood_ so only pawns are influenced by the cards, which may be different from more advanced game versions

We also envision that our codebase can be extended to create a GUI using Java Swing so that the view is upgraded from a textual view and is more pleasant.

**How to Get Started:**
To run the program, head over to the [Sanguine Main Method](src/main/java/sanguine/Sanguine.java) and press the run button.
Alternatively, you can run these commands in the terminal:
javac -d out src/main/java/sanguine/Sanguine.java
java -cp out sanguine.SanguineGame docs/deck.config

**Documentation and Key Components:**
**Key Components:**
- BasicSanguineModel (implements SanguineModel):
  This is the model that represents the game. It tracks the gameboard which contains pawns, cards, or nothing at any given moment. It also enforces turn order, moves, and the influence rules of the cards. Additionally, it deals with scoring and determining the winner. This class essentially drives the control flow of the game objects.

- SanguinePlayer (implements Player):
  This is used as a representation of a player playing Sanguine. There are two main versions: a red and a blue player. They hold a deck and a hand.

- SanguineGameBoard (implements GameBoard):
  This is used as a representation of a game board in Sanguine. It is composed of a class called BasicSanguineBoardCell (implements SanguineBoardCell), which holds game objects like pawns and cards and tracks ownership. This game board is the backbone of a game of Sanguine and exists for there to be a place to put other game objects.

- BasicSanguineCard (implements Card and SanguineCard):
  This is used as a representation of cards in Sanguine. Cards are used as the driving force in a game for players. When players place cards, it influences the game board accordingly, so this is an essential component. Cards have a name, value, cost, and influence grid. The model mentioned above deals with how cards change the state of the game. When toString() is used on this class, it prints the card in this format:
  [Name] [Cost] [Value]
  ROW_0
  ROW_1
  ROW_2
  ROW_3
  ROW_4
  (rows are influence grid)

- PlayerColor & CardColor (enum):
  Player colors define RED and BLUE and are used for board ownership and rendering. Card colors are used in the card class implementation; however, we do not use them within the model. We added this to our codebase because we might need it the future when creating a GUI and displaying card faces.

- TieException:
  This is used in the model whenever a tie between players is detected when scoring the game or finding the winner.

- DeckReader:
  This is used to read and validate deck config files. It parses through card information, ensures that a card's value, cost, and influence grid are valid, and then converts it into a Card object.

- Textual View:
  This is used to render the board row by row. It uses the symbols:
  _: for an empty cell
  1, 2, 3: for pawn counts
  R: for a red player's card
  B: for a blue player's card

- Sanguine (Main Class):
  This allows us to run the program. It reads a deck path from args[0], initializes the model while creating decks for both players and prints the textual view after each move.

**Code Base Organization:**
Sanguine/
- docs/:
1. deck.config
2. example.deck
3. invalidDeckForTests.txt

- src/:
1. Sanguine Main Class

- src/main/java/sanguine/model/:
1. BasicSanguineBoardCell.java
2. BasicSanguineCard.java
3. BasicSanguineModel.java
4. BasicSanguinePawn.java
5. Card.java
6. CardColor.java
7. DeckParser.java
8. GameBoard.java
9. Pawn.java
10. Player.java
11. PlayerColor.java
12. SanguineBoardCell.java
13. SanguineCard.java
14. SanguineGameBoard.java
15. SanguineModel.java
16. SanguinePawn.java
17. SanguinePlayer.java
18. TieException.java

- src/main/java/sanguine/tests
1. CardTests.java
2. CellTests.java
3. DeckParserTest.java
4. GameBoardTests.java
5. PlayerTests.java
6. SanguineModelTests.java
7. TextualViewTests.java


**Changes for part2**
Added Missing Observations to the SanguineModel: 
- The ability to get the contents of a cell at a given coordinate.
    + Solution: new method getCellAt(int row, int col) in the model.
    + This was added because we will need to get the contents of a specific cell for our       GUI when creating cell Panels.
- The ability to get the contents of player's hand.
    + Solution: new method getPlayerHand(PlayerColor color) in the model.
    + This was added so that we can get a specific player's hand for the GUI when              displaying their hand at the bottom of the screen.
- The ability to see which player owns the card or pawns in the cell at a given            coordinate. 
    + Solution: new method getOwnershipOfCell(int row, int col) in the model.
    + This was added so that we can understand which player color to put in the GUI for        a pawn or card.
- Whether it is legal for the current player to play a given card. 
    + Solution: new method placeCardLegal(int row, int col, SanguineCard card,                 SanguinePlayer player) in the model.
    + This was added so that we can know whether a player can place a card in that given       spot for the stub controller. 
 - The ability to get a player's row-score in the game given a row index. 
    + Solution: new method getRowScore(PlayerColor color, int row) in the model.
    + This was added so that we can get the player row scores for the GUI panels that          display the player row scores on the left and right side
- The ability to get a current player's score in the game. 
    + Solution: new method getPlayerHand(PlayerColor color) in the model.
    + This was added so that we can get a specific player's hand for the GUI when              displaying their hand at the bottom of the screen.

**New Classes Created Explanation:**
- We created a SanguineViewFrame, which displays all of our panels that we created which include:
    + CardHandPanel which organizes a collection of CardPanels from both player's when         it is their turn. It formats them in a gridLayout() with unspecified rows and            columns, making it a row of cards. CardPanels display the cards name, value, cost,       and influence grid using Graphics2D. Then CardHandPanel has two helper methods           that display red cards or blue cards. These create a new CardPanel each time             CardHandPanel is refreshed.
    + GameBoardPanel which organizes a collection of CellPanels that either display            pawns, or a card. It formats them in a gridLayout() with specified rows and              columns taken from the model. CellPanels use Graphics2D to draw the pawns or the         card value number. Then GameBoardPanel simply initilizes these cells in the              constructor and it updates accordingly.
- We created a StubController interface and an implementation called SanguineStubController. The controller plays the game and decides what to do when certain events are fired. 
- We created a Listener interface that the Stub Controller implements so that it can decide what to do when certain panels on the screen are clicked or keys are pressed. 

**User Keyboard Input for Move and Pass**
When a player wants to **pass** their turn, they can press 'p' on their keyboard. 
When a player wants to make a **move** for their turn, they can press 'm' on their keyboard. 

**Model Interface Seperation**
- The view takes in a read only (non modifiable model), so we made an interfae for that called ModelReadOnlyInterface.
  - This is isGameOver, getBoard (returning a deep copy), getScore, getWinner, getTurn, getCellAt, getPlayerHand,
  - getOwnerShipOfCell, getRowScore, placeCardLegal
- The controller needs to run methods it, so we created SanguineModifyModel.
    - this is: startGame, createDeck, passTurn, playTurn
- The BasicSanguineModel implements them both. We can make sure that the view can only call view methods to the model,
avoiding the risk of it accidentally changing the model. The controller can access the methods PlayTurn, pass turn, 
createDeck, and startgame. the rest of the methods are private.
- The only changes we had to make was splitting the previous interface that BasicSanguineModel implemented into two,
based off the methods. we then made BasicSanguineModel implement both of those new interfaces. this 

**Extra credit**
- we implemented the MaxOwnership and Minimax strategies in the strategies package. their tests are in the tests package.
